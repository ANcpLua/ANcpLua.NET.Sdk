# MSBuild Polyfills

This directory contains polyfills for various BCL types and attributes that are injected into projects targeting older .NET frameworks, primarily used by MSBuild tasks.

## Usage

To inject the Lock polyfill:

```xml
<PropertyGroup>
  <InjectLockPolyfill>true</InjectLockPolyfill>
</PropertyGroup>
```

To inject the Diagnostic classes:

```xml
<PropertyGroup>
  <InjectDiagnosticClassesOnLegacy>true</InjectDiagnosticClassesOnLegacy>
</PropertyGroup>
```

To inject the Trim attributes:

```xml
<PropertyGroup>
  <InjectTrimAttributesOnLegacy>true</InjectTrimAttributesOnLegacy>
</PropertyGroup>
```

## What gets injected

Reference only: the following C# is shown just to illustrate how the injected code looks.
You do not copy/paste or add these files manually.

<details> <summary><code>Lock.cs</code> (injected)</summary>

```csharp
// <auto-generated/>
#nullable enable
// Copyright (c) ANcpLua. All rights reserved.
// Licensed under the MIT License.

#if !NET9_0_OR_GREATER

namespace System.Threading;

/// <summary>
/// Provides a way to use the System.Threading.Lock class in older frameworks.
/// </summary>
internal sealed class Lock
{
    private readonly object _lock = new();

    /// <summary>
    /// Enters the lock.
    /// </summary>
    public void Enter()
    {
        Monitor.Enter(_lock);
    }

    /// <summary>
    /// Exits the lock.
    /// </summary>
    public void Exit()
    {
        Monitor.Exit(_lock);
    }

    /// <summary>
    /// Enters the lock and returns a scope that exits the lock when disposed.
    /// </summary>
    public Scope EnterScope()
    {
        Monitor.Enter(_lock);
        return new Scope(_lock);
    }

    /// <summary>
    /// A ref struct that exits the lock when disposed.
    /// </summary>
    public readonly ref struct Scope
    {
        private readonly object _lock;

        /// <summary>
        /// Initializes a new instance of the <see cref="Scope"/> struct.
        /// </summary>
        public Scope(object l)
        {
            _lock = l;
        }

        /// <summary>
        /// Exits the lock.
        /// </summary>
        public void Dispose()
        {
            Monitor.Exit(_lock);
        }
    }
}

#endif
```
</details>

<details> <summary><code>DiagnosticClasses.cs</code> (injected)</summary>

```csharp
// <auto-generated/>
#nullable enable
// Copyright (c) Microsoft. All rights reserved.
// Polyfill for diagnostic classes on legacy TFMs

#if NETSTANDARD2_0 || NET472

namespace System.Diagnostics.CodeAnalysis
{
    [AttributeUsage(AttributeTargets.Assembly | AttributeTargets.Module | AttributeTargets.Class | AttributeTargets.Struct |
        AttributeTargets.Enum | AttributeTargets.Constructor | AttributeTargets.Method | AttributeTargets.Property |
        AttributeTargets.Field | AttributeTargets.Event | AttributeTargets.Interface | AttributeTargets.Delegate,
        Inherited = false, AllowMultiple = false)]
    internal sealed class ExcludeFromCodeCoverageAttribute : Attribute
    {
        public string? Justification { get; set; }
    }
}

namespace System.Runtime.CompilerServices
{
    [AttributeUsage(AttributeTargets.Parameter, AllowMultiple = false, Inherited = false)]
    internal sealed class CallerArgumentExpressionAttribute : Attribute
    {
        public CallerArgumentExpressionAttribute(string parameterName) => ParameterName = parameterName;
        public string ParameterName { get; }
    }
}

#endif
```
</details>

<details> <summary><code>TrimAttributes.cs</code> (injected)</summary>

```csharp
// <auto-generated/>
#nullable enable
// Copyright (c) Microsoft. All rights reserved.
// Polyfill for trimming attributes on legacy TFMs

#if NETSTANDARD2_0 || NET472

namespace System.Diagnostics.CodeAnalysis
{
    [AttributeUsage(AttributeTargets.Method | AttributeTargets.Constructor | AttributeTargets.Class, Inherited = false)]
    internal sealed class RequiresUnreferencedCodeAttribute : Attribute
    {
        public RequiresUnreferencedCodeAttribute(string message) => Message = message;
        public string Message { get; }
        public string? Url { get; set; }
    }

    [AttributeUsage(AttributeTargets.All, Inherited = false, AllowMultiple = true)]
    internal sealed class DynamicallyAccessedMembersAttribute : Attribute
    {
        public DynamicallyAccessedMembersAttribute(DynamicallyAccessedMemberTypes memberTypes) => MemberTypes = memberTypes;
        public DynamicallyAccessedMemberTypes MemberTypes { get; }
    }

    [Flags]
    internal enum DynamicallyAccessedMemberTypes
    {
        None = 0,
        PublicParameterlessConstructor = 0x0001,
        PublicConstructors = 0x0003,
        NonPublicConstructors = 0x0004,
        PublicMethods = 0x0008,
        NonPublicMethods = 0x0010,
        PublicFields = 0x0020,
        NonPublicFields = 0x0040,
        PublicNestedTypes = 0x0080,
        NonPublicNestedTypes = 0x0100,
        PublicProperties = 0x0200,
        NonPublicProperties = 0x0400,
        PublicEvents = 0x0800,
        NonPublicEvents = 0x1000,
        Interfaces = 0x2000,
        All = ~None
    }

    [AttributeUsage(AttributeTargets.Method | AttributeTargets.Constructor, Inherited = false)]
    internal sealed class RequiresDynamicCodeAttribute : Attribute
    {
        public RequiresDynamicCodeAttribute(string message) => Message = message;
        public string Message { get; }
        public string? Url { get; set; }
    }

    [AttributeUsage(AttributeTargets.Field | AttributeTargets.ReturnValue | AttributeTargets.GenericParameter |
        AttributeTargets.Parameter | AttributeTargets.Property | AttributeTargets.Method |
        AttributeTargets.Class | AttributeTargets.Interface | AttributeTargets.Struct,
        Inherited = false)]
    internal sealed class DynamicDependencyAttribute : Attribute
    {
        public DynamicDependencyAttribute(string memberSignature) => MemberSignature = memberSignature;
        public DynamicDependencyAttribute(string memberSignature, Type type) { MemberSignature = memberSignature; Type = type; }
        public DynamicDependencyAttribute(string memberSignature, string typeName, string assemblyName) { MemberSignature = memberSignature; TypeName = typeName; AssemblyName = assemblyName; }
        public DynamicDependencyAttribute(DynamicallyAccessedMemberTypes memberTypes, Type type) { MemberTypes = memberTypes; Type = type; }
        public DynamicDependencyAttribute(DynamicallyAccessedMemberTypes memberTypes, string typeName, string assemblyName) { MemberTypes = memberTypes; TypeName = typeName; AssemblyName = assemblyName; }
        public string? MemberSignature { get; }
        public DynamicallyAccessedMemberTypes MemberTypes { get; }
        public Type? Type { get; }
        public string? TypeName { get; }
        public string? AssemblyName { get; }
        public string? Condition { get; set; }
    }

    [AttributeUsage(AttributeTargets.Method | AttributeTargets.Property, Inherited = false, AllowMultiple = true)]
    internal sealed class MemberNotNullAttribute : Attribute
    {
        public MemberNotNullAttribute(string member) => Members = new[] { member };
        public MemberNotNullAttribute(params string[] members) => Members = members;
        public string[] Members { get; }
    }

    [AttributeUsage(AttributeTargets.Method | AttributeTargets.Property, Inherited = false, AllowMultiple = true)]
    internal sealed class MemberNotNullWhenAttribute : Attribute
    {
        public MemberNotNullWhenAttribute(bool returnValue, string member) { ReturnValue = returnValue; Members = new[] { member }; }
        public MemberNotNullWhenAttribute(bool returnValue, params string[] members) { ReturnValue = returnValue; Members = members; }
        public bool ReturnValue { get; }
        public string[] Members { get; }
    }
}

#endif
```
</details>
