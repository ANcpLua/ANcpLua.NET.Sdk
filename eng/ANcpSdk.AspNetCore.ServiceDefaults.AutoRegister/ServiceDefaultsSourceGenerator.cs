using System.Collections.Immutable;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Operations;
using Microsoft.CodeAnalysis.Text;

namespace ANcpSdk.AspNetCore.ServiceDefaults.AutoRegister;

// https://github.com/dotnet/roslyn/blob/main/docs/features/interceptors.md
[Generator]
public sealed class ServiceDefaultsSourceGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var hasServiceDefaults = context.CompilationProvider
            .Select(HasServiceDefaults)
            .WithTrackingName(TrackingNames.ServiceDefaultsAvailable);

        var interceptionCandidates = context.SyntaxProvider
            .CreateSyntaxProvider(IsInvocation, Transform)
            .SelectMany(AsSingletonOrEmpty)
            .WithTrackingName(TrackingNames.InterceptionCandidates)
            .Collect()
            .WithTrackingName(TrackingNames.BuildInvocations);

        context.RegisterSourceOutput(
            interceptionCandidates.Combine(hasServiceDefaults),
            Generate);
    }

    private static bool HasServiceDefaults(Compilation compilation, CancellationToken _)
    {
        return compilation.GetTypeByMetadataName(TypeNames.ServiceDefaults) is not null;
    }

    private static bool IsInvocation(SyntaxNode node, CancellationToken _)
    {
        return node.IsKind(SyntaxKind.InvocationExpression);
    }

    private static ImmutableArray<InterceptionData> AsSingletonOrEmpty(
        InterceptionData? item,
        CancellationToken _)
    {
        return item is not null
            ? [item]
            : ImmutableArray<InterceptionData>.Empty;
    }

    private static void Generate(
        SourceProductionContext context,
        (ImmutableArray<InterceptionData> Candidates, bool HasServiceDefaults) source)
    {
        if (!source.HasServiceDefaults)
            return;

        var sb = new StringBuilder();
        sb.AppendLine("// <auto-generated/>");
        sb.AppendLine("#pragma warning disable");
        sb.AppendLine();
        // Include file-scoped InterceptsLocationAttribute in the same file where it's used
        sb.AppendLine("""
                      namespace System.Runtime.CompilerServices
                      {
                          [global::System.AttributeUsage(global::System.AttributeTargets.Method, AllowMultiple = true)]
                          file sealed class InterceptsLocationAttribute(int version, string data) : global::System.Attribute;
                      }

                      namespace ANcpSdk.AspNetCore.ServiceDefaults.AutoRegister
                      {
                          using ANcpSdk.AspNetCore.ServiceDefaults;

                          file static partial class Interceptors
                          {
                      """);

        var index = 0;
        foreach (var method in source.Candidates
                     .OrderBy(static item => item.OrderKey, StringComparer.Ordinal))
        {
            if (method.Kind is InterceptionMethodKind.Build)
                sb.AppendLine($$"""
                                    // Intercepted call at {{method.InterceptableLocation.GetDisplayLocation()}}
                                    {{method.InterceptableLocation.GetInterceptsLocationAttributeSyntax()}}
                                    public static global::Microsoft.AspNetCore.Builder.WebApplication Intercept_Build{{index}}(
                                        this global::Microsoft.AspNetCore.Builder.WebApplicationBuilder builder)
                                    {
                                        builder.TryUseANcpSdkConventions();
                                        var app = builder.Build();
                                        app.MapANcpSdkDefaultEndpoints();
                                        return app;
                                    }
                                """);

            index++;
        }

        sb.AppendLine("        }"); // close Interceptors class
        sb.AppendLine("    }"); // close namespace
        context.AddSource("Intercepts.g.cs", SourceText.From(sb.ToString(), Encoding.UTF8));
    }

    private static InterceptionData? Transform(GeneratorSyntaxContext context, CancellationToken cancellationToken)
    {
        if (context.SemanticModel.GetOperation(context.Node, cancellationToken) is not IInvocationOperation
            invocation)
            return null;

        if (invocation.TargetMethod.Name is not "Build" ||
            !SymbolEqualityComparer.Default.Equals(
                invocation.TargetMethod.ContainingType,
                context.SemanticModel.Compilation.GetTypeByMetadataName(
                    TypeNames.WebApplicationBuilder))) return null;
        var location = context.SemanticModel.GetInterceptableLocation(
            (InvocationExpressionSyntax)context.Node, cancellationToken);
        if (location is null)
            return null;

        return new InterceptionData
        {
            OrderKey = CreateOrderKey(context.Node),
            Kind = InterceptionMethodKind.Build,
            InterceptableLocation = location
        };

        static string CreateOrderKey(SyntaxNode node)
        {
            var lineSpan = node.GetLocation().GetLineSpan();
            return
                $"{node.SyntaxTree.FilePath}:{lineSpan.StartLinePosition.Line}:{lineSpan.StartLinePosition.Character}";
        }
    }

    private static class TypeNames
    {
        public const string WebApplicationBuilder = "Microsoft.AspNetCore.Builder.WebApplicationBuilder";
        public const string ServiceDefaults = "ANcpSdk.AspNetCore.ServiceDefaults.ANcpSdkServiceDefaults";
    }

    private static class TrackingNames
    {
        public const string BuildInvocations = nameof(BuildInvocations);
        public const string ServiceDefaultsAvailable = nameof(ServiceDefaultsAvailable);
        public const string InterceptionCandidates = nameof(InterceptionCandidates);
    }
}
