using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Operations;
using Microsoft.CodeAnalysis.Text;

#pragma warning disable RS1041
namespace ANcpSdk.AspNetCore.ServiceDefaults.AutoRegister;

// https://github.com/dotnet/roslyn/blob/main/docs/features/interceptors.md
[Generator]
public sealed class ServiceDefaultsSourceGenerator : IIncrementalGenerator
{
    private const string WebApplicationBuilderTypeName = "Microsoft.AspNetCore.Builder.WebApplicationBuilder";
    private const string ServiceDefaultsTypeName = "ANcpSdk.AspNetCore.ServiceDefaults.ANcpSdkServiceDefaults";

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var hasType = context.CompilationProvider.Select(static (compilation, _) =>
            compilation.GetTypeByMetadataName(ServiceDefaultsTypeName) is not null);

        var syntax = context.SyntaxProvider
            .CreateSyntaxProvider(
                static (syntaxNode, _) => syntaxNode.IsKind(SyntaxKind.InvocationExpression),
                Transform)
            .Where(static node => node is not null)
            .Collect();

        var combined = syntax.Combine(hasType);

        context.RegisterSourceOutput(combined,
            static (spc, source) =>
            {
                var (interceptionData, type) = source;
                if (!type)
                    return;

                var sb = new StringBuilder();
                sb.AppendLine("// <auto-generated/>");
                sb.AppendLine("#pragma warning disable");
                sb.AppendLine();
                // Include file-scoped InterceptsLocationAttribute in the same file where it's used
                sb.AppendLine("""
                    namespace System.Runtime.CompilerServices
                    {
                        [global::System.AttributeUsage(global::System.AttributeTargets.Method, AllowMultiple = true)]
                        file sealed class InterceptsLocationAttribute(int version, string data) : global::System.Attribute;
                    }

                    namespace ANcpSdk.AspNetCore.ServiceDefaults.AutoRegister
                    {
                        using ANcpSdk.AspNetCore.ServiceDefaults;

                        file static partial class Interceptors
                        {
                    """);

                var index = 0;
                foreach (var method in interceptionData.Where(m => m is not null)
                             .OrderBy(item => item!.OrderKey, StringComparer.Ordinal))
                {
                    if (method!.Kind is InterceptionMethodKind.Build)
                        sb.AppendLine($$"""
                                            // Intercepted call at {{method.InterceptableLocation.GetDisplayLocation()}}
                                            {{method.InterceptableLocation.GetInterceptsLocationAttributeSyntax()}}
                                            public static global::Microsoft.AspNetCore.Builder.WebApplication Intercept_Build{{index}}(
                                                this global::Microsoft.AspNetCore.Builder.WebApplicationBuilder builder)
                                            {
                                                builder.TryUseANcpSdkConventions();
                                                var app = builder.Build();
                                                app.MapANcpSdkDefaultEndpoints();
                                                return app;
                                            }
                                        """);

                    index++;
                }

                sb.AppendLine("        }"); // close Interceptors class
                sb.AppendLine("    }"); // close namespace
                spc.AddSource("Intercepts.g.cs", SourceText.From(sb.ToString(), Encoding.UTF8));
            });
        return;


        static InterceptionData? Transform(GeneratorSyntaxContext context, CancellationToken cancellationToken)
        {
            if (context.SemanticModel.GetOperation(context.Node, cancellationToken) is not IInvocationOperation
                invocation)
                return null;

            if (invocation.TargetMethod.Name is not "Build" ||
                !SymbolEqualityComparer.Default.Equals(
                    invocation.TargetMethod.ContainingType,
                    context.SemanticModel.Compilation.GetTypeByMetadataName(
                        WebApplicationBuilderTypeName))) return null;
            var location = context.SemanticModel.GetInterceptableLocation(
                (InvocationExpressionSyntax)context.Node, cancellationToken);
            if (location is null)
                return null;

            return new InterceptionData
            {
                OrderKey = CreateOrderKey(context.Node),
                Kind = InterceptionMethodKind.Build,
                InterceptableLocation = location
            };

            static string CreateOrderKey(SyntaxNode node)
            {
                var lineSpan = node.GetLocation().GetLineSpan();
                return
                    $"{node.SyntaxTree.FilePath}:{lineSpan.StartLinePosition.Line}:{lineSpan.StartLinePosition.Character}";
            }
        }
    }
}