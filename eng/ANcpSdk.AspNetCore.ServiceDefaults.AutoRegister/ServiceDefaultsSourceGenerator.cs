using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Operations;
using Microsoft.CodeAnalysis.Text;

#pragma warning disable RS1041
namespace ANcpSdk.AspNetCore.ServiceDefaults.AutoRegister;

// https://github.com/dotnet/roslyn/blob/main/docs/features/interceptors.md
[Generator]
public sealed class ServiceDefaultsSourceGenerator : IIncrementalGenerator
{
    private const string WebApplicationBuilderTypeName = "Microsoft.AspNetCore.Builder.WebApplicationBuilder";
    private const string ServiceDefaultsTypeName = "ANcpSdk.AspNetCore.ServiceDefaults.ANcpSdkServiceDefaults";

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var hasType = context.CompilationProvider.Select(static (compilation, _) =>
            compilation.GetTypeByMetadataName(ServiceDefaultsTypeName) is not null);

        var syntax = context.SyntaxProvider
            .CreateSyntaxProvider(
                static (syntaxNode, _) => syntaxNode.IsKind(SyntaxKind.InvocationExpression),
                Transform)
            .Where(static node => node is not null)
            .Collect();

        var combined = syntax.Combine(hasType);

        context.RegisterSourceOutput(combined,
            static (spc, source) =>
            {
                var (interceptionData, type) = source;
                if (!type)
                    return;

                var sb = new StringBuilder();
                sb.AppendLine("// <auto-generated/>");
                sb.AppendLine("namespace ANcpSdk.AspNetCore.ServiceDefaults.AutoRegister;");
                sb.AppendLine("using ANcpSdk.AspNetCore.ServiceDefaults;");
                sb.AppendLine("file static partial class Interceptors");
                sb.AppendLine("{");

                var index = 0;
                foreach (var method in interceptionData.Where(m => m is not null)
                             .OrderBy(item => item!.OrderKey, StringComparer.Ordinal))
                {
                    if (method!.Kind is InterceptionMethodKind.Build)
                        sb.AppendLine($$"""
                                            // Intercepted call at {{method.InterceptableLocation.GetDisplayLocation()}}
                                            {{method.InterceptableLocation.GetInterceptsLocationAttributeSyntax()}}
                                            public static global::Microsoft.AspNetCore.Builder.WebApplication Intercept_Build{{index}}(
                                                this global::Microsoft.AspNetCore.Builder.WebApplicationBuilder builder)
                                            {
                                                builder.TryUseANcpSdkConventions();
                                                var app = builder.Build();
                                                app.MapANcpSdkDefaultEndpoints();
                                                return app;
                                            }
                                        """);

                    index++;
                }

                sb.AppendLine("}");
                spc.AddSource("Intercepts.g.cs", SourceText.From(sb.ToString(), Encoding.UTF8));
            });

        context.RegisterPostInitializationOutput(static generatorPostInitializationContext =>
        {
            generatorPostInitializationContext.AddSource("InterceptsLocationAttribute.g.cs", SourceText.From("""
                // <auto-generated/>
                #pragma warning disable
                namespace System.Runtime.CompilerServices
                {
                    [global::System.AttributeUsage(global::System.AttributeTargets.Method, AllowMultiple = true)]
                    file sealed class InterceptsLocationAttribute(int version, string data) : global::System.Attribute;
                }
                """, Encoding.UTF8));
        });
        return;


        static InterceptionData? Transform(GeneratorSyntaxContext context, CancellationToken cancellationToken)
        {
            if (context.SemanticModel.GetOperation(context.Node, cancellationToken) is not IInvocationOperation
                invocation)
                return null;

            if (invocation.TargetMethod.Name is not "Build" ||
                !SymbolEqualityComparer.Default.Equals(
                    invocation.TargetMethod.ContainingType,
                    context.SemanticModel.Compilation.GetTypeByMetadataName(
                        WebApplicationBuilderTypeName))) return null;
            var location = context.SemanticModel.GetInterceptableLocation(
                (InvocationExpressionSyntax)context.Node, cancellationToken);
            if (location is null)
                return null;

            return new InterceptionData
            {
                OrderKey = CreateOrderKey(context.Node),
                Kind = InterceptionMethodKind.Build,
                InterceptableLocation = location
            };

            static string CreateOrderKey(SyntaxNode node)
            {
                var lineSpan = node.GetLocation().GetLineSpan();
                return
                    $"{node.SyntaxTree.FilePath}:{lineSpan.StartLinePosition.Line}:{lineSpan.StartLinePosition.Character}";
            }
        }
    }
}