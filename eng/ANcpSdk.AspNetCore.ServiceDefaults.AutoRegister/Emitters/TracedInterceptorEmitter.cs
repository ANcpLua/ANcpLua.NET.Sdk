using System.Collections.Immutable;
using System.Text;
using ANcpSdk.AspNetCore.ServiceDefaults.AutoRegister.Models;
using Microsoft.CodeAnalysis.CSharp;

namespace ANcpSdk.AspNetCore.ServiceDefaults.AutoRegister.Emitters;

/// <summary>
///     Emits interceptor source code for methods decorated with [Traced] attribute.
/// </summary>
internal static class TracedInterceptorEmitter
{
    /// <summary>
    ///     Emits the interceptor source code for all traced invocations.
    /// </summary>
    public static string Emit(ImmutableArray<TracedInvocationInfo> invocations)
    {
        if (invocations.IsEmpty)
            return string.Empty;

        var sb = new StringBuilder();

        AppendFileHeader(sb);
        AppendUsings(sb);
        AppendInterceptsLocationAttribute(sb);
        AppendActivitySourcesClass(sb, invocations);
        AppendClassOpen(sb);
        AppendInterceptorMethods(sb, invocations);
        AppendClassClose(sb);

        return sb.ToString();
    }

    private static void AppendFileHeader(StringBuilder sb)
    {
        sb.AppendLine("// <auto-generated/>");
        sb.AppendLine("#pragma warning disable");
        sb.AppendLine();
    }

    private static void AppendUsings(StringBuilder sb)
    {
        sb.AppendLine("using System.Diagnostics;");
        sb.AppendLine();
    }

    private static void AppendInterceptsLocationAttribute(StringBuilder sb)
    {
        sb.AppendLine("""
                      namespace System.Runtime.CompilerServices
                      {
                          [global::System.AttributeUsage(global::System.AttributeTargets.Method, AllowMultiple = true)]
                          file sealed class InterceptsLocationAttribute(int version, string data) : global::System.Attribute;
                      }
                      """);
        sb.AppendLine();
    }

    /// <summary>
    ///     Maps original ActivitySource names to unique field names.
    ///     Thread-local to avoid issues with parallel compilation.
    /// </summary>
    [ThreadStatic]
    private static Dictionary<string, string>? _activitySourceFieldNames;

    private static void AppendActivitySourcesClass(StringBuilder sb, ImmutableArray<TracedInvocationInfo> invocations)
    {
        // Collect unique ActivitySource names and create unique field names
        var activitySourceNames = invocations
            .Select(static i => i.ActivitySourceName)
            .Distinct(StringComparer.Ordinal)
            .OrderBy(static n => n, StringComparer.Ordinal)
            .ToList();

        // Build a mapping from original name to unique field name
        _activitySourceFieldNames = new Dictionary<string, string>(StringComparer.Ordinal);
        var usedFieldNames = new HashSet<string>(StringComparer.Ordinal);

        foreach (var name in activitySourceNames)
        {
            var baseFieldName = SanitizeFieldName(name);
            var fieldName = baseFieldName;
            var counter = 1;

            // Ensure uniqueness
            while (!usedFieldNames.Add(fieldName))
            {
                fieldName = $"{baseFieldName}_{counter++}";
            }

            _activitySourceFieldNames[name] = fieldName;
        }

        sb.AppendLine("namespace ANcpSdk.AspNetCore.ServiceDefaults.AutoRegister");
        sb.AppendLine("{");
        sb.AppendLine("    file static class TracedActivitySources");
        sb.AppendLine("    {");

        foreach (var name in activitySourceNames)
        {
            var fieldName = _activitySourceFieldNames[name];
            sb.AppendLine($"        internal static readonly global::System.Diagnostics.ActivitySource {fieldName} = new(\"{name}\");");
        }

        sb.AppendLine("    }");
        sb.AppendLine("}");
        sb.AppendLine();
    }

    private static string GetActivitySourceFieldName(string activitySourceName)
    {
        return _activitySourceFieldNames?.TryGetValue(activitySourceName, out var fieldName) == true
            ? fieldName
            : SanitizeFieldName(activitySourceName);
    }

    private static string SanitizeFieldName(string activitySourceName)
    {
        // Convert "MyApp.Orders" to "MyApp_Orders"
        var sanitized = new StringBuilder();
        foreach (var c in activitySourceName)
        {
            sanitized.Append(char.IsLetterOrDigit(c) ? c : '_');
        }
        return sanitized.ToString();
    }

    private static void AppendClassOpen(StringBuilder sb)
    {
        sb.AppendLine("""
                      namespace ANcpSdk.AspNetCore.ServiceDefaults.AutoRegister
                      {
                          file static class TracedInterceptors
                          {
                      """);
    }

    private static void AppendInterceptorMethods(
        StringBuilder sb,
        ImmutableArray<TracedInvocationInfo> invocations)
    {
        var orderedInvocations = invocations
            .OrderBy(static i => i.OrderKey, StringComparer.Ordinal);

        var index = 0;
        foreach (var invocation in orderedInvocations)
        {
            AppendSingleInterceptor(sb, invocation, index);
            index++;
        }
    }

    private static void AppendSingleInterceptor(
        StringBuilder sb,
        TracedInvocationInfo invocation,
        int index)
    {
        var displayLocation = invocation.InterceptableLocation.GetDisplayLocation();
        var interceptAttribute = invocation.InterceptableLocation.GetInterceptsLocationAttributeSyntax();

        var methodName = $"Intercept_Traced_{index}";
        var returnType = ToGlobalTypeName(invocation.ReturnTypeName);
        var containingType = invocation.ContainingTypeName;
        var originalMethod = invocation.MethodName;
        var activitySourceField = GetActivitySourceFieldName(invocation.ActivitySourceName);

        var parameters = BuildParameterList(invocation, containingType);
        var arguments = BuildArgumentList(invocation);
        var tagSetters = BuildTagSetters(invocation);
        var methodCall = invocation.IsStatic
            ? $"global::{containingType}.{originalMethod}({arguments})"
            : $"@this.{originalMethod}({arguments})";

        if (invocation.IsAsync)
        {
            EmitAsyncInterceptor(sb, invocation, methodName, returnType, parameters,
                displayLocation, interceptAttribute, activitySourceField, tagSetters, methodCall);
        }
        else
        {
            EmitSyncInterceptor(sb, invocation, methodName, returnType, parameters,
                displayLocation, interceptAttribute, activitySourceField, tagSetters, methodCall);
        }
    }

    private static void EmitAsyncInterceptor(
        StringBuilder sb,
        TracedInvocationInfo invocation,
        string methodName,
        string returnType,
        string parameters,
        string displayLocation,
        string interceptAttribute,
        string activitySourceField,
        string tagSetters,
        string methodCall)
    {
        var hasReturnValue = !returnType.EndsWith("Task", StringComparison.Ordinal) &&
                            !returnType.EndsWith("ValueTask", StringComparison.Ordinal);

        sb.AppendLine($$"""
                // Intercepted call at {{displayLocation}}
                {{interceptAttribute}}
                public static async {{returnType}} {{methodName}}({{parameters}})
                {
                    using var activity = TracedActivitySources.{{activitySourceField}}.StartActivity(
                        "{{invocation.SpanName}}",
                        global::System.Diagnostics.ActivityKind.{{invocation.SpanKind}});
        """);

        if (!string.IsNullOrEmpty(tagSetters))
        {
            sb.AppendLine();
            sb.AppendLine("            if (activity is not null)");
            sb.AppendLine("            {");
            sb.Append(tagSetters);
            sb.AppendLine("            }");
        }

        sb.AppendLine();

        if (hasReturnValue)
        {
            sb.AppendLine($$"""
                    try
                    {
                        var result = await {{methodCall}};
                        activity?.SetStatus(global::System.Diagnostics.ActivityStatusCode.Ok);
                        return result;
                    }
                    catch (global::System.Exception ex)
                    {
                        activity?.SetStatus(global::System.Diagnostics.ActivityStatusCode.Error, ex.Message);
                        activity?.AddEvent(new global::System.Diagnostics.ActivityEvent("exception", tags: new global::System.Diagnostics.ActivityTagsCollection { { "exception.type", ex.GetType().FullName }, { "exception.message", ex.Message } }));
                        throw;
                    }
                }

        """);
        }
        else
        {
            sb.AppendLine($$"""
                    try
                    {
                        await {{methodCall}};
                        activity?.SetStatus(global::System.Diagnostics.ActivityStatusCode.Ok);
                    }
                    catch (global::System.Exception ex)
                    {
                        activity?.SetStatus(global::System.Diagnostics.ActivityStatusCode.Error, ex.Message);
                        activity?.AddEvent(new global::System.Diagnostics.ActivityEvent("exception", tags: new global::System.Diagnostics.ActivityTagsCollection { { "exception.type", ex.GetType().FullName }, { "exception.message", ex.Message } }));
                        throw;
                    }
                }

        """);
        }
    }

    private static void EmitSyncInterceptor(
        StringBuilder sb,
        TracedInvocationInfo invocation,
        string methodName,
        string returnType,
        string parameters,
        string displayLocation,
        string interceptAttribute,
        string activitySourceField,
        string tagSetters,
        string methodCall)
    {
        var hasReturnValue = returnType != "void";

        sb.AppendLine($$"""
                // Intercepted call at {{displayLocation}}
                {{interceptAttribute}}
                public static {{returnType}} {{methodName}}({{parameters}})
                {
                    using var activity = TracedActivitySources.{{activitySourceField}}.StartActivity(
                        "{{invocation.SpanName}}",
                        global::System.Diagnostics.ActivityKind.{{invocation.SpanKind}});
        """);

        if (!string.IsNullOrEmpty(tagSetters))
        {
            sb.AppendLine();
            sb.AppendLine("            if (activity is not null)");
            sb.AppendLine("            {");
            sb.Append(tagSetters);
            sb.AppendLine("            }");
        }

        sb.AppendLine();

        if (hasReturnValue)
        {
            sb.AppendLine($$"""
                    try
                    {
                        var result = {{methodCall}};
                        activity?.SetStatus(global::System.Diagnostics.ActivityStatusCode.Ok);
                        return result;
                    }
                    catch (global::System.Exception ex)
                    {
                        activity?.SetStatus(global::System.Diagnostics.ActivityStatusCode.Error, ex.Message);
                        activity?.AddEvent(new global::System.Diagnostics.ActivityEvent("exception", tags: new global::System.Diagnostics.ActivityTagsCollection { { "exception.type", ex.GetType().FullName }, { "exception.message", ex.Message } }));
                        throw;
                    }
                }

        """);
        }
        else
        {
            sb.AppendLine($$"""
                    try
                    {
                        {{methodCall}};
                        activity?.SetStatus(global::System.Diagnostics.ActivityStatusCode.Ok);
                    }
                    catch (global::System.Exception ex)
                    {
                        activity?.SetStatus(global::System.Diagnostics.ActivityStatusCode.Error, ex.Message);
                        activity?.AddEvent(new global::System.Diagnostics.ActivityEvent("exception", tags: new global::System.Diagnostics.ActivityTagsCollection { { "exception.type", ex.GetType().FullName }, { "exception.message", ex.Message } }));
                        throw;
                    }
                }

        """);
        }
    }

    private static string BuildParameterList(TracedInvocationInfo invocation, string containingType)
    {
        var sb = new StringBuilder();

        // Static methods don't have a 'this' parameter
        if (!invocation.IsStatic)
        {
            sb.Append($"this global::{containingType} @this");
        }

        for (var i = 0; i < invocation.ParameterTypes.Count; i++)
        {
            if (sb.Length > 0)
                sb.Append(", ");
            var typeName = ToGlobalTypeName(invocation.ParameterTypes[i]);
            sb.Append($"{typeName} {invocation.ParameterNames[i]}");
        }

        return sb.ToString();
    }

    /// <summary>
    ///     Converts a type name to a fully qualified global:: format.
    ///     Handles C# keyword aliases like string, int, decimal, etc.
    /// </summary>
    private static string ToGlobalTypeName(string typeName)
    {
        // Handle nullable types
        var isNullable = typeName.EndsWith("?", StringComparison.Ordinal);
        var baseType = isNullable ? typeName[..^1] : typeName;
        var suffix = isNullable ? "?" : "";

        // Map C# keyword aliases to their BCL names
        var mapped = baseType switch
        {
            "string" => "System.String",
            "int" => "System.Int32",
            "long" => "System.Int64",
            "short" => "System.Int16",
            "byte" => "System.Byte",
            "sbyte" => "System.SByte",
            "uint" => "System.UInt32",
            "ulong" => "System.UInt64",
            "ushort" => "System.UInt16",
            "float" => "System.Single",
            "double" => "System.Double",
            "decimal" => "System.Decimal",
            "bool" => "System.Boolean",
            "char" => "System.Char",
            "object" => "System.Object",
            "void" => "void",
            _ => baseType
        };

        return mapped == "void" ? "void" : $"global::{mapped}{suffix}";
    }

    private static string BuildArgumentList(TracedInvocationInfo invocation)
    {
        if (invocation.ParameterNames.Count == 0)
            return string.Empty;

        return string.Join(", ", invocation.ParameterNames);
    }

    private static string BuildTagSetters(TracedInvocationInfo invocation)
    {
        if (invocation.TracedTags.Count == 0)
            return string.Empty;

        var sb = new StringBuilder();

        foreach (var tag in invocation.TracedTags)
        {
            if (tag.SkipIfNull && tag.IsNullable)
            {
                sb.AppendLine($"                if ({tag.ParameterName} is not null)");
                sb.AppendLine($"                    activity.SetTag(\"{tag.TagName}\", {tag.ParameterName});");
            }
            else
            {
                sb.AppendLine($"                activity.SetTag(\"{tag.TagName}\", {tag.ParameterName});");
            }
        }

        return sb.ToString();
    }

    private static void AppendClassClose(StringBuilder sb)
    {
        sb.AppendLine("""
                          }
                      }
                      """);
    }
}
