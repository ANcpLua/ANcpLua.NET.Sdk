# Trim Attributes Polyfills

This directory contains polyfills for various .NET trimming and AOT (Ahead-of-Time) compilation related attributes (
e.g., `RequiresUnreferencedCodeAttribute`, `DynamicallyAccessedMembersAttribute`). These enable the use of modern
trimming annotations in projects targeting older .NET frameworks.

## Usage

To inject these trim attribute polyfills into your project, set the following property in your `.csproj` file:

```xml
<PropertyGroup>
  <InjectANcpLuaTrimAttributesPolyfills>true</InjectANcpLuaTrimAttributesPolyfills>
</PropertyGroup>
```

## What gets injected

Reference only: the following C# is shown just to illustrate how the injected code looks.
You do not copy/paste or add these files manually.

<details> <summary><code>DynamicallyAccessedMembersAttribute.cs</code> (injected)</summary>

```csharp
// <auto-generated/>
#nullable enable
// Copyright (c) ANcpLua. All rights reserved.
// Licensed under the MIT License.

using System;
using System.Diagnostics.CodeAnalysis;

namespace System.Diagnostics.CodeAnalysis;

/// <summary>
///     Indicates that certain members on a specified <see cref="Type" /> are accessed dynamically.
/// </summary>
[AttributeUsage(
    AttributeTargets.Field | AttributeTargets.ReturnValue | AttributeTargets.GenericParameter |
    AttributeTargets.Parameter | AttributeTargets.Property | AttributeTargets.Method |
    AttributeTargets.Class | AttributeTargets.Interface | AttributeTargets.Struct,
    Inherited = false)]
[ExcludeFromCodeCoverage]
internal sealed class DynamicallyAccessedMembersAttribute : Attribute
{
    /// <summary>
    ///     Initializes a new instance of the <see cref="DynamicallyAccessedMembersAttribute" /> class.
    /// </summary>
    /// <param name="memberTypes">The types of members dynamically accessed.</param>
    public DynamicallyAccessedMembersAttribute(DynamicallyAccessedMemberTypes memberTypes)
    {
        MemberTypes = memberTypes;
    }

    /// <summary>
    ///     Gets the <see cref="DynamicallyAccessedMemberTypes" /> which specifies the type of members dynamically accessed.
    /// </summary>
    public DynamicallyAccessedMemberTypes MemberTypes { get; }
}
```

</details>

<details> <summary><code>DynamicallyAccessedMemberTypes.cs</code> (injected)</summary>

```csharp
// <auto-generated/>
#nullable enable
// Copyright (c) ANcpLua. All rights reserved.
// Licensed under the MIT License.

using System;

#pragma warning disable RCS1157 // Composite enum value contains undefined flag

namespace System.Diagnostics.CodeAnalysis;

/// <summary>
///     Specifies the types of members that are dynamically accessed.
///     This enumeration has a <see cref="FlagsAttribute" /> attribute that allows a bitwise combination of its member
///     values.
/// </summary>
[Flags]
internal enum DynamicallyAccessedMemberTypes
{
    /// <summary>Specifies no members.</summary>
    None = 0,

    /// <summary>Specifies the default, parameterless public constructor.</summary>
    PublicParameterlessConstructor = 0x0001,

    /// <summary>Specifies all public constructors.</summary>
    PublicConstructors = 0x0002 | PublicParameterlessConstructor,

    /// <summary>Specifies all non-public constructors.</summary>
    NonPublicConstructors = 0x0004,

    /// <summary>Specifies all public methods.</summary>
    PublicMethods = 0x0008,

    /// <summary>Specifies all non-public methods.</summary>
    NonPublicMethods = 0x0010,

    /// <summary>Specifies all public fields.</summary>
    PublicFields = 0x0020,

    /// <summary>Specifies all non-public fields.</summary>
    NonPublicFields = 0x0040,

    /// <summary>Specifies all public nested types.</summary>
    PublicNestedTypes = 0x0080,

    /// <summary>Specifies all non-public nested types.</summary>
    NonPublicNestedTypes = 0x0100,

    /// <summary>Specifies all public properties.</summary>
    PublicProperties = 0x0200,

    /// <summary>Specifies all non-public properties.</summary>
    NonPublicProperties = 0x0400,

    /// <summary>Specifies all public events.</summary>
    PublicEvents = 0x0800,

    /// <summary>Specifies all non-public events.</summary>
    NonPublicEvents = 0x1000,

    /// <summary>Specifies all interfaces implemented by the type.</summary>
    Interfaces = 0x2000,

    /// <summary>Specifies all members.</summary>
    All = ~None
}
```

</details>

<details> <summary><code>RequiresDynamicCodeAttribute.cs</code> (injected)</summary>

```csharp
// <auto-generated/>
#nullable enable
// Copyright (c) ANcpLua. All rights reserved.
// Licensed under the MIT License.

using System;
using System.Diagnostics.CodeAnalysis;

namespace System.Diagnostics.CodeAnalysis; // Corrected namespace

/// <summary>
///     Indicates that the specified method requires the ability to generate new code at runtime.
/// </summary>
[AttributeUsage(AttributeTargets.Method | AttributeTargets.Constructor | AttributeTargets.Class, Inherited = false)]
[ExcludeFromCodeCoverage]
internal sealed class RequiresDynamicCodeAttribute : Attribute
{
    /// <summary>
    ///     Initializes a new instance of the <see cref="RequiresDynamicCodeAttribute" /> class.
    /// </summary>
    /// <param name="message">A message that contains information about the usage of dynamic code.</param>
    public RequiresDynamicCodeAttribute(string message)
    {
        Message = message;
    }

    /// <summary>Gets a message that contains information about the usage of dynamic code.</summary>
    public string Message { get; }

    /// <summary>Gets or sets an optional URL that contains more information about the method.</summary>
    public string? Url { get; set; }
}
```

</details>

<details> <summary><code>RequiresUnreferencedCodeAttribute.cs</code> (injected)</summary>

```csharp
// <auto-generated/>
#nullable enable
// Copyright (c) ANcpLua. All rights reserved.
// Licensed under the MIT License.

using System;
using System.Diagnostics.CodeAnalysis;

namespace System.Diagnostics.CodeAnalysis;

/// <summary>
///     Indicates that the specified method requires dynamic access to code that is not referenced
///     statically, for example through <see cref="System.Reflection" />.
/// </summary>
[AttributeUsage(AttributeTargets.Method | AttributeTargets.Constructor | AttributeTargets.Class, Inherited = false)]
[ExcludeFromCodeCoverage]
internal sealed class RequiresUnreferencedCodeAttribute : Attribute
{
    /// <summary>
    ///     Initializes a new instance of the <see cref="RequiresUnreferencedCodeAttribute" /> class.
    /// </summary>
    /// <param name="message">A message that contains information about the usage of unreferenced code.</param>
    public RequiresUnreferencedCodeAttribute(string message)
    {
        Message = message;
    }

    /// <summary>Gets a message that contains information about the usage of unreferenced code.</summary>
    public string Message { get; }

    /// <summary>Gets or sets an optional URL that contains more information about the method.</summary>
    public string? Url { get; set; }
}
```

</details>

<details> <summary><code>UnconditionalSuppressMessageAttribute.cs</code> (injected)</summary>

```csharp
// <auto-generated/>
#nullable enable
// Copyright (c) ANcpLua. All rights reserved.
// Licensed under the MIT License.

using System;
using System.Diagnostics;
using System.Diagnostics.CodeAnalysis;

namespace System.Diagnostics.CodeAnalysis; // Corrected namespace

/// <summary>
///     Suppresses reporting of a specific rule violation, allowing multiple suppressions on a single code artifact.
/// </summary>
/// <remarks>
///     <see cref="UnconditionalSuppressMessageAttribute" /> is different than <see cref="SuppressMessageAttribute" />
///     in that it doesn't have a <see cref="ConditionalAttribute" />. So it is always preserved in the compiled assembly.
/// </remarks>
[AttributeUsage(AttributeTargets.All, Inherited = false, AllowMultiple = true)]
[ExcludeFromCodeCoverage]
internal sealed class UnconditionalSuppressMessageAttribute : Attribute
{
    /// <summary>
    ///     Initializes a new instance of the <see cref="UnconditionalSuppressMessageAttribute" /> class.
    /// </summary>
    /// <param name="category">The category for the attribute.</param>
    /// <param name="checkId">The identifier of the analysis rule the attribute applies to.</param>
    public UnconditionalSuppressMessageAttribute(string category, string checkId)
    {
        Category = category;
        CheckId = checkId;
    }

    /// <summary>Gets the category identifying the classification of the attribute.</summary>
    public string Category { get; }

    /// <summary>Gets the identifier of the analysis tool rule to be suppressed.</summary>
    public string CheckId { get; }

    /// <summary>Gets or sets the scope of the code that is relevant for the attribute.</summary>
    public string? Scope { get; set; }

    /// <summary>Gets or sets a fully qualified path that represents the target of the attribute.</summary>
    public string? Target { get; set; }

    /// <summary>Gets or sets an optional argument expanding on exclusion criteria.</summary>
    public string? MessageId { get; set; }

    /// <summary>Gets or sets the justification for suppressing the code analysis message.</summary>
    public string? Justification { get; set; }
}
```

</details>