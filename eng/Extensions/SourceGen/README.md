# SourceGen

Roslyn symbol extensions and helpers for Source Generators.

To use this in your project, add the following to your `.csproj` file:

```xml
<PropertyGroup>
  <InjectSourceGenHelpers>true</InjectSourceGenHelpers>
</PropertyGroup>
```

This will also define the `ANCPLUA_SOURCEGEN_HELPERS` constant required by these files.

## What gets injected

Reference only: the following C# is shown just to illustrate how the injected code looks.
You do not copy/paste or add these files manually.

<details> <summary><code>AnalyzerConfigOptionsProviderExtensions.cs</code> (injected)</summary>

```csharp
// <auto-generated/>
#nullable enable
// Copyright (c) ANcpLua. All rights reserved.
// Licensed under the MIT License.

#if ANCPLUA_SOURCEGEN_HELPERS

using Microsoft.CodeAnalysis.Diagnostics;

namespace ANcpLua.SourceGen;

/// <summary>
/// Extension methods for <see cref="AnalyzerConfigOptionsProvider"/>.
/// </summary>
internal static class AnalyzerConfigOptionsProviderExtensions
{
    public static bool GetBoolOption(
        this AnalyzerConfigOptionsProvider options,
        string propertyName,
        bool defaultValue = false)
    {
        if (options.GlobalOptions.TryGetValue($"build_property.{propertyName}", out var valueStr) &&
            bool.TryParse(valueStr, out var value))
        {
            return value;
        }

        return defaultValue;
    }
}

#endif
```
</details>

<details> <summary><code>CompilationExtensions.cs</code> (injected)</summary>

```csharp
// <auto-generated/>
#nullable enable
// Copyright (c) ANcpLua. All rights reserved.
// Licensed under the MIT License.

#if ANCPLUA_SOURCEGEN_HELPERS

using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;

namespace ANcpLua.SourceGen;

/// <summary>
/// Extension methods for <see cref="Compilation"/>.
/// </summary>
internal static class CompilationExtensions
{
    /// <summary>
    /// Retrieves a well-known type from the compilation.
    /// </summary>
    /// <param name="compilation">The compilation.</param>
    /// <param name="fullyQualifiedMetadataName">The fully qualified metadata name of the type.</param>
    /// <returns>The <see cref="INamedTypeSymbol"/> if found, otherwise <c>null</c>.</returns>
    public static INamedTypeSymbol? GetTypeByMetadataName(this Compilation compilation, string fullyQualifiedMetadataName)
    {
        return compilation.GetTypeByMetadataName(fullyQualifiedMetadataName);
    }

    /// <summary>
    /// Determines if the compilation is using C# language version 9.0 or greater.
    /// </summary>
    public static bool IsCSharp9OrGreater(this Compilation compilation)
    {
        return ((CSharpParseOptions)compilation.ParseOptions).LanguageVersion >= LanguageVersion.CSharp9;
    }

    /// <summary>
    /// Determines if the compilation is using C# language version 10.0 or greater.
    /// </summary>
    public static bool IsCSharp10OrGreater(this Compilation compilation)
    {
        return ((CSharpParseOptions)compilation.ParseOptions).LanguageVersion >= LanguageVersion.CSharp10;
    }

    /// <summary>
    /// Determines if the compilation is using C# language version 11.0 or greater.
    /// </summary>
    public static bool IsCSharp11OrGreater(this Compilation compilation)
    {
        return ((CSharpParseOptions)compilation.ParseOptions).LanguageVersion >= LanguageVersion.CSharp11;
    }
}

#endif
```
</details>

<details> <summary><code>DiagnosticInfo.cs</code> (injected)</summary>

```csharp
// <auto-generated/>
#nullable enable
// Copyright (c) ANcpLua. All rights reserved.
// Licensed under the MIT License.

#if ANCPLUA_SOURCEGEN_HELPERS

using Microsoft.CodeAnalysis;

namespace ANcpLua.SourceGen;

/// <summary>
/// Represents information about a diagnostic.
/// </summary>
internal sealed record DiagnosticInfo(
    string Id,
    string Title,
    string MessageFormat,
    DiagnosticSeverity Severity,
    string Category);

#endif
```
</details>

<details> <summary><code>DiagnosticsExtensions.cs</code> (injected)</summary>

```csharp
// <auto-generated/>
#nullable enable
// Copyright (c) ANcpLua. All rights reserved.
// Licensed under the MIT License.

#if ANCPLUA_SOURCEGEN_HELPERS

using Microsoft.CodeAnalysis;

namespace ANcpLua.SourceGen;

/// <summary>
/// Extension methods for <see cref="Diagnostic"/>.
/// </summary>
internal static class DiagnosticsExtensions
{
    public static Diagnostic CreateDiagnostic(this DiagnosticInfo info, Location location, params object?[] messageArgs)
    {
        return Diagnostic.Create(
            new DiagnosticDescriptor(
                info.Id,
                info.Title,
                info.MessageFormat,
                info.Category,
                info.Severity,
                isEnabledByDefault: true),
            location,
            messageArgs);
    }
}

#endif
```
</details>

<details> <summary><code>EquatableArray.cs</code> (injected)</summary>

```csharp
// <auto-generated/>
#nullable enable
// Copyright (c) ANcpLua. All rights reserved.
// Licensed under the MIT License.

#if ANCPLUA_SOURCEGEN_HELPERS

using System;
using System.Collections.Immutable;
using System.Diagnostics.CodeAnalysis;

namespace ANcpLua.SourceGen;

/// <summary>
/// A custom <see cref="IEquatable{T}"/> and <see cref="IEqualityComparer{T}"/> for <see cref="ImmutableArray{T}"/>.
/// </summary>
internal readonly struct EquatableArray<T> : IEquatable<EquatableArray<T>>
    where T : IEquatable<T>
{
    private readonly ImmutableArray<T> _array;

    public EquatableArray(ImmutableArray<T> array)
    {
        _array = array;
    }

    public ImmutableArray<T> AsImmutableArray() => _array;

    public bool Equals(EquatableArray<T> other)
    {
        if (_array.IsDefault && other._array.IsDefault)
        {
            return true;
        }

        if (_array.IsDefault || other._array.IsDefault)
        {
            return false;
        }

        if (_array.Length != other._array.Length)
        {
            return false;
        }

        for (var i = 0; i < _array.Length; i++)
        {
            if (!_array[i].Equals(other._array[i]))
            {
                return false;
            }
        }

        return true;
    }

    public override bool Equals([NotNullWhen(true)] object? obj) => obj is EquatableArray<T> other && Equals(other);

    public override int GetHashCode()
    {
        if (_array.IsDefault)
        {
            return 0;
        }

        var hashCode = 0;
        foreach (var item in _array)
        {
            hashCode = HashCode.Combine(hashCode, item.GetHashCode());
        }

        return hashCode;
    }
}

#endif
```
</details>

<details> <summary><code>EquatableMessageArgs.cs</code> (injected)</summary>

```csharp
// <auto-generated/>
#nullable enable
// Copyright (c) ANcpLua. All rights reserved.
// Licensed under the MIT License.

#if ANCPLUA_SOURCEGEN_HELPERS

using System;
using System.Collections.Immutable;
using System.Diagnostics.CodeAnalysis;

namespace ANcpLua.SourceGen;

/// <summary>
/// A custom <see cref="IEquatable{T}"/> and <see cref="IEqualityComparer{T}"/> for message arguments.
/// </summary>
internal readonly struct EquatableMessageArgs : IEquatable<EquatableMessageArgs>
{
    private readonly ImmutableArray<object?> _args;

    public EquatableMessageArgs(ImmutableArray<object?> args)
    {
        _args = args;
    }

    public bool Equals(EquatableMessageArgs other)
    {
        if (_args.IsDefault && other._args.IsDefault)
        {
            return true;
        }

        if (_args.IsDefault || other._args.IsDefault)
        {
            return false;
        }

        if (_args.Length != other._args.Length)
        {
            return false;
        }

        for (var i = 0; i < _args.Length; i++)
        {
            if (!Equals(_args[i], other._args[i]))
            {
                return false;
            }
        }

        return true;
    }

    public override bool Equals([NotNullWhen(true)] object? obj) => obj is EquatableMessageArgs other && Equals(other);

    public override int GetHashCode()
    {
        if (_args.IsDefault)
        {
            return 0;
        }

        var hashCode = 0;
        foreach (var item in _args)
        {
            hashCode = HashCode.Combine(hashCode, item?.GetHashCode() ?? 0);
        }

        return hashCode;
    }
}

#endif
```
</details>

<details> <summary><code>LocationInfo.cs</code> (injected)</summary>

```csharp
// <auto-generated/>
#nullable enable
// Copyright (c) ANcpLua. All rights reserved.
// Licensed under the MIT License.

#if ANCPLUA_SOURCEGEN_HELPERS

using Microsoft.CodeAnalysis;

namespace ANcpLua.SourceGen;

/// <summary>
/// Represents information about a diagnostic location.
/// </summary>
internal sealed record LocationInfo(
    string Path,
    int StartLine,
    int StartCharacter,
    int EndLine,
    int EndCharacter);

#endif
```
</details>

<details> <summary><code>SourceProductionContextExtensions.cs</code> (injected)</summary>

```csharp
// <auto-generated/>
#nullable enable
// Copyright (c) ANcpLua. All rights reserved.
// Licensed under the MIT License.

#if ANCPLUA_SOURCEGEN_HELPERS

using Microsoft.CodeAnalysis;

namespace ANcpLua.SourceGen;

/// <summary>
/// Extension methods for <see cref="SourceProductionContext"/>.
/// </summary>
internal static class SourceProductionContextExtensions
{
    public static void ReportDiagnostic(this SourceProductionContext context, DiagnosticInfo info, Location location, params object?[] messageArgs)
    {
        context.ReportDiagnostic(info.CreateDiagnostic(location, messageArgs));
    }

    public static void ReportDiagnostic(this SourceProductionContext context, DiagnosticInfo info, SyntaxNode node, params object?[] messageArgs)
    {
        context.ReportDiagnostic(info.CreateDiagnostic(node.GetLocation(), messageArgs));
    }

    public static void ReportDiagnostic(this SourceProductionContext context, DiagnosticInfo info, SyntaxToken token, params object?[] messageArgs)
    {
        context.ReportDiagnostic(info.CreateDiagnostic(token.GetLocation(), messageArgs));
    }
}

#endif
```
</details>

<details> <summary><code>SymbolExtensions.cs</code> (injected)</summary>

```csharp
// <auto-generated/>
#nullable enable
// Copyright (c) ANcpLua. All rights reserved.
// Licensed under the MIT License.

#if ANCPLUA_SOURCEGEN_HELPERS

using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using System;
using System.Linq;
using System.Threading;

namespace ANcpLua.SourceGen;

/// <summary>
/// Extension methods for <see cref="ISymbol"/>.
/// </summary>
internal static class SymbolExtensions
{
    /// <summary>
    /// Gets the fully qualified metadata name of a type symbol.
    /// </summary>
    public static string GetMetadataName(this ITypeSymbol symbol)
    {
        return symbol.ToDisplayString(SymbolDisplayFormat.CSharpErrorMessageFormat);
    }

    /// <summary>
    /// Checks if a type symbol has a specific attribute.
    /// </summary>
    public static bool HasAttribute(this ISymbol symbol, string fullyQualifiedAttributeName)
    {
        foreach (var attribute in symbol.GetAttributes())
        {
            if (attribute.AttributeClass?.ToDisplayString() == fullyQualifiedAttributeName)
            {
                return true;
            }
        }

        return false;
    }

    /// <summary>
    /// Gets the first attribute matching the specified name, or null.
    /// </summary>
    public static AttributeData? GetAttribute(this ISymbol symbol, string fullyQualifiedAttributeName)
    {
        foreach (var attribute in symbol.GetAttributes())
        {
            if (attribute.AttributeClass?.ToDisplayString() == fullyQualifiedAttributeName)
            {
                return attribute;
            }
        }

        return null;
    }

    /// <summary>
    /// Checks if a type is or inherits from a specific base type.
    /// </summary>
    public static bool IsOrInheritsFrom(this ITypeSymbol? symbol, string fullyQualifiedTypeName)
    {
        while (symbol is not null)
        {
            if (symbol.ToDisplayString() == fullyQualifiedTypeName)
            {
                return true;
            }

            symbol = symbol.BaseType;
        }

        return false;
    }

    /// <summary>
    /// Checks if a type implements a specific interface.
    /// </summary>
    public static bool ImplementsInterface(this ITypeSymbol symbol, string fullyQualifiedInterfaceName)
    {
        foreach (var iface in symbol.AllInterfaces)
        {
            if (iface.ToDisplayString() == fullyQualifiedInterfaceName)
            {
                return true;
            }
        }

        return false;
    }

    /// <summary>
    /// Gets the containing namespace as a string, or empty if global.
    /// </summary>
    public static string GetNamespaceName(this ISymbol symbol)
    {
        var ns = symbol.ContainingNamespace;
        return ns.IsGlobalNamespace ? string.Empty : ns.ToDisplayString();
    }
}

#endif
```
</details>

<details> <summary><code>SyntaxValueProviderExtensions.cs</code> (injected)</summary>

```csharp
// <auto-generated/>
#nullable enable
// Copyright (c) ANcpLua. All rights reserved.
// Licensed under the MIT License.

#if ANCPLUA_SOURCEGEN_HELPERS
using System.Threading;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace ANcpLua.SourceGen;

/// <summary>
/// Extension methods for <see cref="SyntaxValueProvider"/> to simplify common patterns.
/// </summary>
internal static class SyntaxValueProviderExtensions
{
    /// <summary>
    /// Creates a provider for class declarations with a specific attribute.
    /// </summary>
    public static IncrementalValuesProvider<ClassDeclarationSyntax> ForClassesWithAttribute(
        this SyntaxValueProvider provider,
        string attributeName)
    {
        return provider.CreateSyntaxProvider(
            predicate: (node, _) => IsClassWithAttribute(node, attributeName),
            transform: (ctx, _) => (ClassDeclarationSyntax)ctx.Node);
    }

    /// <summary>
    /// Creates a provider for method declarations with a specific attribute.
    /// </summary>
    public static IncrementalValuesProvider<MethodDeclarationSyntax> ForMethodsWithAttribute(
        this SyntaxValueProvider provider,
        string attributeName)
    {
        return provider.CreateSyntaxProvider(
            predicate: (node, _) => IsMethodWithAttribute(node, attributeName),
            transform: (ctx, _) => (MethodDeclarationSyntax)ctx.Node);
    }

    /// <summary>
    /// Creates a provider that filters by attribute and transforms with semantic model.
    /// </summary>
    public static IncrementalValuesProvider<T> ForAttributeWithMetadataName<T>(
        this SyntaxValueProvider provider,
        string fullyQualifiedMetadataName,
        System.Func<SyntaxNode, CancellationToken, bool> predicate,
        System.Func<GeneratorAttributeSyntaxContext, CancellationToken, T> transform)
    {
        return provider.ForAttributeWithMetadataName(
            fullyQualifiedMetadataName,
            predicate,
            transform);
    }

    private static bool IsClassWithAttribute(SyntaxNode node, string attributeName)
    {
        return node is ClassDeclarationSyntax classDecl &&
               HasAttributeWithName(classDecl.AttributeLists, attributeName);
    }

    private static bool IsMethodWithAttribute(SyntaxNode node, string attributeName)
    {
        return node is MethodDeclarationSyntax methodDecl &&
               HasAttributeWithName(methodDecl.AttributeLists, attributeName);
    }

    private static bool HasAttributeWithName(SyntaxList<AttributeListSyntax> attributeLists, string attributeName)
    {
        foreach (var attributeList in attributeLists)
        {
            foreach (var attribute in attributeList.Attributes)
            {
                var name = attribute.Name.ToString();
                if (name == attributeName ||
                    name == attributeName + "Attribute" ||
                    name.EndsWith("." + attributeName) ||
                    name.EndsWith("." + attributeName + "Attribute"))
                {
                    return true;
                }
            }
        }

        return false;
    }
}

#endif
```
</details>
